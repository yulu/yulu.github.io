<!DOCTYPE html>
<html>

    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>[DDIA] Chapter 3 - Storage and Retrieval</title>
    <meta name="description" content="I am migrating from a blog service provider to github, still trying out with Jekyll
">

    <link rel="stylesheet" href="/css/main.css">
    <link rel="canonical" href="http://localhost:4000/blog1/2022/07/27/ddia-3.html">
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link href="/css/nav.css" type="text/css" rel="stylesheet" />
    <script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>

    <!-- Go to www.addthis.com/dashboard to customize your tools -->
    <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-551ec72a4d0e58c1" async="async"></script>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-PB2VMZMH');</script>
    <!-- End Google Tag Manager -->
    <!--latex-->
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <meta name="google-site-verification" content="x60nHOyc_rEQN3p4MCF7G6h-7Yvng4iMYB06RrSZNS4" />
</head>

    
    <body>

    <header>
    <div class="site-header">
        <a href="/"><span>Little<b>CheeseCake.</b></span></a>
    </div>
    <!--nav button-->
<div class="button-background">
    <div class="button-toggle" id="toggle">

        <span class="top"></span>
        <span class="middle_1"></span>
        <span class="middle_2"></span>
        <span class="bottom"></span>
    </div>
</div>
<!--menu overlay-->
<div class="overlay" id="overlay">
    <nav>
        <ul>
            <li><a href="/index.html">Home</a></li>
            <li><a href="/blog2/index.html">Journal</a></li>
            <li><a href="/blog1/index.html">Tech Blog</a></li>
            <li><a href="/books/index.html">Books</li>
            <li><a href="https://www.youtube.com/user/YuLu8798" target="_blank">Vlog</a></li>
            <li><a href="/about/about.html">About</a></li>
        </ul>
    </nav>
</div>
<!--jquery script-->
<script>
    $('.button-background').click(function() {
        $('#toggle').toggleClass('active');
        $('#overlay').toggleClass('open');
    });
</script>

</header>


    <div class="post-image-container">
        
        <img class="post-image" src="https://s3.ap-southeast-1.amazonaws.com/littlecheesecake.me/blog-post/effective-learning/effective_learning_header.jpeg"/>
              
        
        
        
          
    </div>

    <div class="post-wrapper">
        <!-- header -->

        <div class="wrapper">
            <header class="post-header">
                <h1 class="post-title">[DDIA] Chapter 3 - Storage and Retrieval</h1>
                <p class="post-meta">Jul 27, 2022</p>
            </header>
        </div>

        <!-- table of content -->
        <div class="post-toc" id="toc"> <ul id="toc" class="section-nav">
<li class="toc-entry toc-h3"><a href="#chapter-summary">Chapter Summary</a></li>
<li class="toc-entry toc-h3"><a href="#mind-map">Mind Map</a></li>
<li class="toc-entry toc-h3"><a href="#questions-summary">Questions Summary</a></li>
<li class="toc-entry toc-h3"><a href="#highlighted-topics">Highlighted Topics</a>
<ul>
<li class="toc-entry toc-h4"><a href="#simple-storage">Simple Storage</a></li>
<li class="toc-entry toc-h4"><a href="#hash-index-storage">Hash Index Storage</a></li>
<li class="toc-entry toc-h4"><a href="#lsm-tree-storage">LSM Tree storage</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#extended-topics">Extended Topics</a></li>
</ul> </div> 

        <article class="post-content">
            <h3 id="chapter-summary">Chapter Summary</h3>

<p>This is an interesting and exciting chapter! Finally it starts to talk about data systems. The discussion starts from the illustration of how data store can be done with a simple text file. Extending from the concept, a simple storage engine with appending-only log is introduced - hash index. The basic knowledge makes the understanding of the classic LSM-tree storage engine easy. Complement to the LSM-tree storage engine, another classic B-tree storage engine is discussed in detail.</p>

<p>In the second section of the chapter, the difference between OLAP and OLTP databases is discussed. Diving deeper into the OLAP and data warehouse concept, column-oriented data storage engine is introduced.</p>

<h3 id="mind-map">Mind Map</h3>

<div class="mindmap-container">
    <iframe src="https://www.xmind.net/embed/H5bX6h" width="900px" height="540px" frameborder="0" scrolling="no"></iframe>
</div>

<h3 id="questions-summary">Questions Summary</h3>

<p>ðŸ’¡ 1. How does Hash Indexes work?</p>

<p>Key-value stores are used (similar to the hashmap data structure). The key is the index key and the value is byte offset of the value in the data file. The hash index is stored in memory for fast access. When reading the data from the index, we can read the byte offset of the key from the index, and we only need to load the value data from the disk with just one disk seek.
The data file is append only and compaction and segment merging are performed to reduce the storage</p>

<p>ðŸ’¡ 2. What is compaction (of a key-value update log)?</p>

<p>For a log-structure database, compaction on the log file segments means throwing away duplicate keys in the log and keeping only the most recent update for each key.</p>

<p>ðŸ’¡ 3. How to handle partially written records in hash index?</p>

<p>Use checksums to delete the corrupted parts of the log</p>

<p>ðŸ’¡ 4. How to handle the data deleting in hash index?</p>

<p>Append a special deletion record to the data file (called tombstone). When log segments are merged, the tombstone tells the merging process to discard any previous value for the deleted key</p>

<p>ðŸ’¡ 5. What is checksums?</p>

<p>A checksum is an alphanumeric value that uniquely represents the contents of a file. Checksums are often used to verify the integrity of files downloaded from external source.</p>

<p>ðŸ’¡ 6. What are the limitations of hash index?</p>

<ul>
  <li>the hash table must fit in memory, it does not work for data that has a very large number of keys</li>
  <li>range queries are not support, you need to fetch data key one by one for a range of keys</li>
</ul>

<p>ðŸ’¡ 7. What are the two ways to solve the issue of a key-value index where the key is not unique?</p>

<ul>
  <li>making each value stored with the keys a list of matching row identifier</li>
  <li>by appending a row identifier to the key to make the key unique</li>
</ul>

<p>ðŸ’¡ 8. What is the reason that in-memory data storage performs faster than disk-based data storage?</p>

<p>The overhead resides mainly in the data encoding and decoding process as data stored in very different structure in memory and in disk. Surprisingly the read speed to memory and disk is not the deciding factor although they are in huge difference. (Anyway, the disk-based storage could avoid read from disk given enough memory provided and data cached)</p>

<p>ðŸ’¡ 9. What is LSM tree?</p>

<p>Log-structured Merge-tree. Storage engines that are based on the principle of <strong>merging and compacting sorted files</strong> are often called LSM storage engines.</p>

<p>ðŸ’¡ 10. How does the LSM-tree storage engine works (SSTable + Memtable)?</p>

<ul>
  <li>write to the in-memory sorted balanced tree (red-black tree), also called a memtable</li>
  <li>when the memtable size is larger than a threshold, write to the disk as SSTable. When copying is ongoing, the newly coming write will go to a new memtable</li>
  <li>to process a read request, first check the memtable, if does not find, check the latest SSTable and so on.</li>
  <li>on the background, a process will periodically performing merging and compaction on the SSTables to delete data and remove duplicates</li>
  <li>bloom filter is added as a first layer to check the existence of the key before it hits to the memtable and SSTables</li>
</ul>

<p>ðŸ’¡ 11. What is a memtable?</p>

<p>It is a in-memory cache of the latest set of record writes applied to the database. It is normally in a data structure (e.g. red-black tree) that supports log(n) time for insert and lookup.
The memtable will be write to disk as an SSTable after the size passes some threshold.</p>

<p>ðŸ’¡ 12. How does the LSM-tree storage engine improve the read efficiency for non-existing key?</p>

<ul>
  <li>Use a bloom filter to check if key exists before searching for the keys in memtable and SSTables</li>
</ul>

<p>ðŸ’¡ 13. How does a LSM-tree storage engine handle server crash?</p>

<p>The server crash will cause the lost of memtable. In this case, the service will keep a separate append-only log file in disk to record each operation write to the memtable. This is only used to recover the memtable from crash.</p>

<p>ðŸ’¡ 14. How does a B-tree storage engine work?</p>

<ul>
  <li>B-trees break the database down into fixed size blocks or pages (usually 4kb in size) and read or write one page at a time</li>
  <li>Each page can be identified using an address or location, which allows one page to refer to another, we can use these page reference to construct a tree of pages</li>
  <li>when performing read, start from the root of the b-tree and look for the child page the key resides until reaching the leaf page</li>
  <li>when performing write, search for the leaf key, then caching the value in that page and writing it back to disk after update. If there isnâ€™t enough space accommodate the new key, it creates a new page and updates the parentâ€™s pointer to point to the new page</li>
</ul>

<p>ðŸ’¡ 15. What is a heap file?</p>

<p>When the db index stores the valueâ€™s identifier, the actual data of the value is stored in a place called heap file. Often it stores data in no particular order. It is common because it avoids duplicating data when multiple secondary indexes are present.</p>

<p>ðŸ’¡ 16. What is a clustered index?</p>

<p>It is refer to the type of index that the value stored directly with the key in the index, instead of an identifier of the value stored. This will ensure a better performance than the later. One example is that MySQL InnoDB storage engine, the primary key of a table is always a clustered index, and the secondary indexes refer to the primary key (not using heap file)</p>

<p>ðŸ’¡ 17. Compare B-trees and LSM-trees?</p>

<ul>
  <li>B-tree is used to support page-oriented storage engine (used in MySQL, MongoDB etc). It stores the key and value (location to the value) and reference to other pages as small chucked pages in a tree-structure to allow efficient access to the keys</li>
  <li>LSM-trees is used to support log-structured storage engines (e.g. LevelDB). It consists of a in-memory memtable and in-disk SSTables. The memtable provides fast write and read and keeps the key in sorted order. The data in memtable is periodically loaded to SSTable for persistence. Merging and compacting is performed on SSTables to remove duplications</li>
  <li>B-tree enabled data storage is better suitable for read-heavy applications while LSM-trees database is more suitable for write-heavy applications. B-tree is more mature compared to LSM-trees.</li>
</ul>

<p>ðŸ’¡ 18. Why some wide-column database e.g. BigTable, Cassandra, Hbase are not column-oriented database?</p>

<p>These database are not column stores in the original sense of the term, since their two-level structures do not use a columnar data layout. They introduces the column-family concept. Within each column family, they store all columns from a row together, along with a row key, and they do not use column compression.</p>

<p>ðŸ’¡ 19. What are OLTP and OLAP? What are the main differences?</p>

<p>Online transactional processing vs online analytical processing.</p>
<ul>
  <li>read pattern: OLTP is for a small number of record per query, OLAP aggregate over large number of records</li>
  <li>write pattern: OLTP is for random access with low latency, OLAP is for bulk import or event stream</li>
  <li>end users: OLTP for web app and end users, OLAP for data analytics and decision maker</li>
  <li>data representation: OLTP represents the latest state of the data, OLAP represents the historical events</li>
  <li>data size: OLTP - GB to TB, OLAP - TB to PB</li>
</ul>

<h3 id="highlighted-topics">Highlighted Topics</h3>

<p>I find the discussion about the LSM-tree storage engine is really interesting and inspiring in this chapter. Here I use illustrations to describe how a simplest storage solution (a plain file) can be extend and evolved to an efficient and full-functional storage engine.</p>

<h4 id="simple-storage">Simple Storage</h4>

<p>A plain text file as a simple storage engine is illustrated below. The write operations (insert/update/delete) is always append to the end of the log file. The read operation is always start from the beginning and scan to the end. This results to a simple structure, extremely terrible read performance and unbeatable efficient write performance.</p>

<p><img src="https://s3.ap-southeast-1.amazonaws.com/littlecheesecake.me/blog-post/ddia-3/ddia-3-simple-storage.excalidraw.png" alt="" /></p>

<h4 id="hash-index-storage">Hash Index Storage</h4>

<p>To improve the read efficiency, the concept of hash index is introduced. It is a in-memory hash map to store the key and the offset to the log file where the value is appended. Use the offset information, one disk seek is required to fetch the value. Compaction and merging strategy is used to reduce the log file size resulting from the append-only write strategy</p>

<p><img src="https://s3.ap-southeast-1.amazonaws.com/littlecheesecake.me/blog-post/ddia-3/ddia-3-hash-index.excalidraw.png" alt="" /></p>

<h4 id="lsm-tree-storage">LSM Tree storage</h4>

<p>One of the problem of hash index storage engine is the hash index has to be fit into the memory. Memtable and SSTable are introduced in LSM-tree storage to solve the problem. Sorted key concept here is very important. It makes the searching and merging efficient with the sorted nature of the key. Bloom filter and write-ahead log are some common technics to improve the performance and reliability.</p>

<p><img src="https://s3.ap-southeast-1.amazonaws.com/littlecheesecake.me/blog-post/ddia-3/ddia-3-lsm-tree.excalidraw.png" alt="" /></p>

<h3 id="extended-topics">Extended Topics</h3>

<p>B-tree and B*-tree storage engines</p>

<blockquote>
  <p>TODO; just want to publish this post sooner to motivate myself to continue to write</p>
</blockquote>



            <div class="post-end">
                <!-- buy me a coffee -->
                <div>
                    <a href="https://www.buymeacoffee.com/8QcoMFJNHD" target="_blank"><img src="https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png" alt="Buy Me A Coffee" style="height: 40px !important;width: 150px !important;" ></a>
                </div>
                <div class="share-container">
                    <!-- Go to www.addthis.com/dashboard to customize your tools -->
                    <span class="share-text">Share the post </span><div class="addthis_sharing_toolbox"></div>
                </div>
                <div id="disqus_thread"></div>
<script>
/**
* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');

s.src = '//littlecheesecakeme.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
            </div>
        </article>
    </div>

    <footer>
     <div class="site-footer page">
         <p>Build with love, <a href="http://jekyllrb.com">Jekyll</a> and <a href="http://github.com/yulu/yulu.github.io">Github Page</a> by <a href="/about/about.html"><em>Yu Lu</em></a></p>
    </div>
    
</footer>
    
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PB2VMZMH"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    </body>

    <!--jquery script for sticky toc-->
    <script>
        window.onscroll = function() {myFunction()};

        // Get the header
        var header = document.getElementById("toc");

        // Get the offset position of the navbar
        var sticky = header.offsetTop;

        // Add the sticky class to the header when you reach its scroll position. Remove "sticky" when you leave the scroll position
        function myFunction() {
            if (window.pageYOffset > sticky) {
                header.classList.add("sticky");
            } else {
                header.classList.remove("sticky");
            }
        }
    </script>
</html>
